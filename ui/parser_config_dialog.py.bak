from typing import Self, TYPE_CHECKING
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from ttkbootstrap.toast import ToastNotification
from ttkbootstrap.scrolled import ScrolledFrame
import json


class ParserConfigWindow(ttk.Toplevel):
    def __init__(self, parent, sender_email, rule_data):
        super().__init__(parent)
        self.sender_email = sender_email
        self.rule_data = rule_data
        self.configurations = []  # Список конфигураций парсера

        self.title(f"Конфигурации парсера - {sender_email}")
        self.geometry("800x600")

        # Центрируем окно
        self.update_idletasks()
        x = (self.winfo_screenwidth() - self.winfo_width()) // 2
        y = (self.winfo_screenheight() - self.winfo_height()) // 2
        self.geometry(f"+{x}+{y}")

        self._create_widgets()

    def _create_widgets(self):
        # Основной контейнер
        main_frame = ttk.Frame(self)
        main_frame.pack(fill=BOTH, expand=YES, padx=10, pady=10)

        # Заголовок
        ttk.Label(
            main_frame,
            text=f"Настройка конфигураций парсера для: {self.sender_email}",
            font=("Helvetica", 12, "bold")
        ).pack(anchor=W, pady=(0, 15))

        # Информация о правиле
        info_frame = ttk.LabelFrame(main_frame, text="Текущее правило фильтрации")
        info_frame.pack(fill=X, pady=(0, 15))

        info_text = f"Отправитель: {self.sender_email}\n"
        if self.rule_data.get('subject_contains'):
            info_text += f"Тема содержит: {self.rule_data['subject_contains']}\n"
        if self.rule_data.get('extensions'):
            info_text += f"Расширения: {self.rule_data['extensions']}\n"
        if self.rule_data.get('filename_contains'):
            info_text += f"Имя файла содержит: {self.rule_data['filename_contains']}\n"
        if self.rule_data.get('filename_excludes'):
            info_text += f"Имя файла НЕ содержит: {self.rule_data['filename_excludes']}\n"

        ttk.Label(info_frame, text=info_text, justify=LEFT).pack(anchor=W, padx=10, pady=10)

        # Заголовок раздела конфигураций
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill=X, pady=(0, 10))

        ttk.Label(
            header_frame,
            text="Конфигурации парсера для разных форматов:",
            font=("Helvetica", 10, "bold")
        ).pack(side=LEFT, anchor=W)

        ttk.Button(
            header_frame,
            text="+ Добавить конфигурацию",
            bootstyle=SUCCESS,
            command=self._add_configuration
        ).pack(side=RIGHT)

        # Прокручиваемая область для конфигураций
        self.configs_frame = ScrolledFrame(main_frame, height=300)
        self.configs_frame.pack(fill=BOTH, expand=YES, pady=(0, 15))

        # Кнопки внизу
        btn_frame = ttk.Frame(main_frame)
        btn_frame.pack(fill=X, pady=10)

        ttk.Button(
            btn_frame,
            text="Сохранить все конфигурации",
            bootstyle=SUCCESS,
            command=self._save_all_configurations
        ).pack(side=RIGHT, padx=(10, 0))

        ttk.Button(
            btn_frame,
            text="Загрузить письма",
            bootstyle=INFO,
            command=self._load_emails_mock
        ).pack(side=RIGHT, padx=(10, 0))

        ttk.Button(
            btn_frame,
            text="Закрыть",
            bootstyle=SECONDARY,
            command=self.destroy
        ).pack(side=RIGHT)

        # Загружаем моковые данные
        self._load_mock_configurations()

    def _load_mock_configurations(self):
        """Загружает примеры конфигураций для демонстрации"""
        mock_configs = [
            {
                'name': 'Основной прайс',
                'filename_pattern': 'прайс',
                'vendor': 'Техносите',
                'config_name': 'Техносите_основной'
            },
            {
                'name': 'Акционный прайс',
                'filename_pattern': 'акция',
                'vendor': 'Техносите',
                'config_name': 'Техносите_акции'
            },
            {
                'name': 'Остатки',
                'filename_pattern': 'остатки',
                'vendor': 'Техносите',
                'config_name': 'Техносите_остатки'
            }
        ]

        for config_data in mock_configs:
            self._add_config_frame(config_data)

    def _load_emails_mock(self):
        """Моковая функция загрузки писем"""
        # Создаем моковые данные писем
        mock_emails = [
            {"subject": "Прайс-лист на ноябрь", "filename": "прайс_ноябрь.xlsx", "date": "2024-11-20"},
            {"subject": "Акционные товары", "filename": "акция_декабрь.xls", "date": "2024-11-18"},
            {"subject": "Остатки на складе", "filename": "остатки_склад.xlsx", "date": "2024-11-15"},
            {"subject": "Внешний заказ", "filename": "внешний_заказ.xlsx", "date": "2024-11-10"},
            {"subject": "Прайс обновленный", "filename": "прайс_новый.xlsm", "date": "2024-11-08"},
        ]

        # Фильтруем по правилу
        filtered_emails = self._filter_emails_by_rule(mock_emails)

        # Показываем диалог с результатами
        self._show_email_results(filtered_emails)

    def _filter_emails_by_rule(self, emails):
        """Фильтрует письма по текущему правилу"""
        filtered = []

        for email in emails:
            # Проверка расширения
            if self.rule_data.get('extensions'):
                ext_ok = any(email['filename'].lower().endswith(ext.strip())
                             for ext in self.rule_data['extensions'].split(','))
                if not ext_ok:
                    continue

            # Проверка темы
            if self.rule_data.get('subject_contains'):
                subject_ok = any(keyword.strip().lower() in email['subject'].lower()
                                 for keyword in self.rule_data['subject_contains'].split(','))
                if not subject_ok:
                    continue

            # Проверка имени файла (содержит)
            if self.rule_data.get('filename_contains'):
                filename_ok = any(keyword.strip().lower() in email['filename'].lower()
                                  for keyword in self.rule_data['filename_contains'].split(','))
                if not filename_ok:
                    continue

            # Проверка имени файла (НЕ содержит)
            if self.rule_data.get('filename_excludes'):
                filename_ex_ok = not any(keyword.strip().lower() in email['filename'].lower()
                                         for keyword in self.rule_data['filename_excludes'].split(','))
                if not filename_ex_ok:
                    continue

            filtered.append(email)

        return filtered

    def _show_email_results(self, emails):
        """Показывает результаты фильтрации писем"""
        result_window = ttk.Toplevel(self)
        result_window.title("Результаты загрузки писем")
        result_window.geometry("600x400")

        # Центрируем окно
        result_window.update_idletasks()
        x = (result_window.winfo_screenwidth() - result_window.winfo_width()) // 2
        y = (result_window.winfo_screenheight() - result_window.winfo_height()) // 2
        result_window.geometry(f"+{x}+{y}")

        ttk.Label(
            result_window,
            text=f"Найдено писем: {len(emails)}",
            font=("Helvetica", 11, "bold")
        ).pack(pady=10)

        # Таблица с письмами
        tree_frame = ttk.Frame(result_window)
        tree_frame.pack(fill=BOTH, expand=YES, padx=10, pady=10)

        tree = ttk.Treeview(tree_frame, columns=("subject", "filename", "date"), show="headings", height=15)
        tree.heading("subject", text="Тема")
        tree.heading("filename", text="Файл")
        tree.heading("date", text="Дата")

        tree.column("subject", width=250)
        tree.column("filename", width=200)
        tree.column("date", width=100)

        for email in emails:
            tree.insert("", END, values=(email['subject'], email['filename'], email['date']))

        vsb = ttk.Scrollbar(tree_frame, orient=VERTICAL, command=tree.yview)
        tree.configure(yscroll=vsb.set)
        tree.pack(side=LEFT, fill=BOTH, expand=YES)
        vsb.pack(side=RIGHT, fill=Y)

        ttk.Button(
            result_window,
            text="Закрыть",
            bootstyle=SECONDARY,
            command=result_window.destroy
        ).pack(pady=10)

        result_window.transient(self)
        result_window.grab_set()

        # Фокус на новом окне
        result_window.focus_set()

    def _add_configuration(self):
        """Добавляет новую конфигурацию парсера"""
        config_data = {
            'name': 'Новая конфигурация',
            'filename_pattern': '',
            'vendor': self.sender_email.split('@')[0],  # Берем имя из email
            'config_name': f"{self.sender_email.split('@')[0]}_новая"
        }
        self._add_config_frame(config_data)

    def _add_config_frame(self, config_data):
        """Добавляет фрейм конфигурации"""
        config_frame = ttk.LabelFrame(self.configs_frame, text=config_data['name'])
        config_frame.pack(fill=X, pady=5, padx=5)

        # Основные настройки конфигурации
        settings_frame = ttk.Frame(config_frame)
        settings_frame.pack(fill=X, padx=10, pady=10)

        # Название конфигурации
        ttk.Label(settings_frame, text="Название:", width=12).grid(row=0, column=0, sticky=W, pady=2)
        name_var = ttk.StringVar(value=config_data['name'])
        name_entry = ttk.Entry(settings_frame, textvariable=name_var, width=25)
        name_entry.grid(row=0, column=1, sticky=W, pady=2, padx=5)

        # Шаблон имени файла
        ttk.Label(settings_frame, text="Шаблон файла:", width=12).grid(row=1, column=0, sticky=W, pady=2)
        pattern_var = ttk.StringVar(value=config_data['filename_pattern'])
        pattern_entry = ttk.Entry(settings_frame, textvariable=pattern_var, width=25)
        pattern_entry.grid(row=1, column=1, sticky=W, pady=2, padx=5)

        # Поставщик
        ttk.Label(settings_frame, text="Поставщик:", width=12).grid(row=2, column=0, sticky=W, pady=2)
        vendor_var = ttk.StringVar(value=config_data['vendor'])
        vendor_entry = ttk.Entry(settings_frame, textvariable=vendor_var, width=25)
        vendor_entry.grid(row=2, column=1, sticky=W, pady=2, padx=5)

        # Имя конфигурации
        ttk.Label(settings_frame, text="Конфиг парсера:", width=12).grid(row=3, column=0, sticky=W, pady=2)
        config_var = ttk.StringVar(value=config_data['config_name'])
        config_entry = ttk.Entry(settings_frame, textvariable=config_var, width=25)
        config_entry.grid(row=3, column=1, sticky=W, pady=2, padx=5)

        # Кнопки действий
        btn_frame = ttk.Frame(settings_frame)
        btn_frame.grid(row=4, column=0, columnspan=2, pady=5, sticky=W)

        ttk.Button(
            btn_frame,
            text="Настроить парсер",
            bootstyle=PRIMARY,
            command=lambda: self._configure_parser(config_data)
        ).pack(side=LEFT, padx=(0, 10))

        ttk.Button(
            btn_frame,
            text="Удалить",
            bootstyle=DANGER,
            command=config_frame.destroy
        ).pack(side=LEFT)

        # Сохраняем ссылки на переменные
        config_frame.vars = {
            'name': name_var,
            'pattern': pattern_var,
            'vendor': vendor_var,
            'config_name': config_var
        }

        self.configurations.append(config_frame)

    def _configure_parser(self, config_data):
        """Открывает настройки парсера для этой конфигурации"""
        try:
            from parser import PriceParserApp

            # Здесь можно передать настройки в парсер
            parser_window = ttk.Toplevel(self)
            parser_window.title(f"Парсер - {config_data['name']}")
            parser_window.geometry("1200x750")

            # Центрируем окно парсера
            parser_window.update_idletasks()
            x = (parser_window.winfo_screenwidth() - parser_window.winfo_width()) // 2
            y = (parser_window.winfo_screenheight() - parser_window.winfo_height()) // 2
            parser_window.geometry(f"+{x}+{y}")

            # Передаем vendor и config_name в парсер
            PriceParserApp(
                parent=parser_window,
                vendor=config_data['vendor'],
                file_in="",  # Файл будет выбран позже
                file_prefix="",
                config_name=config_data['config_name']
            )
        except ImportError as e:
            ToastNotification(
                title="Ошибка",
                message=f"Не удалось импортировать парсер: {e}",
                bootstyle=DANGER
            ).show_toast()
        except Exception as e:
            ToastNotification(
                title="Ошибка",
                message=f"Ошибка открытия парсера: {e}",
                bootstyle=DANGER
            ).show_toast()

    def _save_all_configurations(self):
        """Сохраняет все конфигурации"""
        saved_configs = []

        for config_frame in self.configurations:
            if config_frame.winfo_exists():
                config_data = {
                    'name': config_frame.vars['name'].get(),
                    'filename_pattern': config_frame.vars['pattern'].get(),
                    'vendor': config_frame.vars['vendor'].get(),
                    'config_name': config_frame.vars['config_name'].get()
                }
                saved_configs.append(config_data)

        # Здесь будет сохранение в БД
        ToastNotification(
            title="Сохранено",
            message=f"Сохранено {len(saved_configs)} конфигураций парсера",
            bootstyle=SUCCESS
        ).show_toast()