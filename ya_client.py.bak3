import imaplib
import email
import traceback
from email.header import decode_header
import os
import re
from datetime import datetime, timedelta
from email.utils import parseaddr, parsedate_to_datetime
from pathlib import Path
from typing import List, Dict, Optional, Union
import chardet

import settings
from crud import (add_letter, add_attachment, list_vendors, add_vendor,
                  get_vendor_name_by_id, get_email_filter_by_vendor,
                  update_letter, delete_attachments_by_letter, list_configs_for_vendor_id)
from models import Letter, Attachment, Filters
from utils.imap import decode_folder_name
from utils.paths import pm


class YandexIMAPClient:
    def __init__(self, email: str, password: str, imap_server: str = "imap.yandex.ru", port: int = 993):
        self.end_dt = None
        self.start_dt = None
        self.db_scope: List[Filters] = []
        self.scope = None
        self.exluded_folders = [
            "Outbox", "Spam", "Trash", "\"Drafts|template\"",
            "Drafts", "Archive", "Sent"
        ]
        self.email = email
        self.password = password
        self.imap_server = imap_server
        self.port = port
        self.mail = None
        self.connected = False
        self.senders = []
        self.vendors = list_vendors()

    def set_folders_to_exculde(self, folders: List[str]):
        self.exluded_folders = folders

    def set_credentials(self, email: str, password: str, imap_server: str = "imap.yandex.ru", port: int = 993):
        self.email = email
        self.password = password
        self.imap_server = imap_server
        self.port = port

    def connect(self) -> bool:
        """–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ IMAP —Å–µ—Ä–≤–µ—Ä—É –Ø–Ω–¥–µ–∫—Å"""
        try:
            self.mail = imaplib.IMAP4_SSL(self.imap_server, self.port)
            self.mail.login(self.email, self.password)
            self.connected = True
            print(f"–£—Å–ø–µ—à–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ {self.email}")
            return True
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {e}")
            return False

    def disconnect(self):
        """–û—Ç–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞"""
        if self.mail and self.connected:
            self.mail.logout()
            self.connected = False
            print("–û—Ç–∫–ª—é—á–µ–Ω–æ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞")

    def list_folders(self) -> List[str]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –ø–∞–ø–æ–∫"""
        if not self.connected:
            return []

        try:
            status, folders = self.mail.list()
            if status == "OK":
                return [folder.decode() for folder in folders]
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ø–∞–ø–æ–∫: {e}")
        return []

    def select_folder(self, folder: str = "INBOX") -> bool:
        """–í—ã–±–æ—Ä –ø–∞–ø–∫–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã"""
        if not self.connected:
            return False

        try:
            status, data = self.mail.select(folder, readonly=True)
            return status == "OK"
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –≤—ã–±–æ—Ä–∞ –ø–∞–ø–∫–∏ {folder}: {e}")
            return False

    def search_emails(self, criteria: str = "ALL") -> List[str]:
        """–ü–æ–∏—Å–∫ –ø–∏—Å–µ–º –ø–æ –∫—Ä–∏—Ç–µ—Ä–∏—è–º"""
        if not self.connected:
            print("#ERR EMail —è—â–∏–∫ –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω!")
            return []

        try:
            status, messages = self.mail.uid('SEARCH', None, criteria)
            if status == "OK":
                return [msg.decode() if isinstance(msg, bytes) else str(msg)
                        for msg in messages[0].split()]
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –ø–∏—Å–µ–º: {e}")
        return []

    def _build_date_criteria(self, days: int = None, since_date: datetime = None,
                             before_date: datetime = None) -> str:
        """–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –∫—Ä–∏—Ç–µ—Ä–∏–µ–≤ –ø–æ–∏—Å–∫–∞ –ø–æ –¥–∞—Ç–µ"""
        if days:
            since_date = datetime.now() - timedelta(days=days)

        if since_date:
            self.start_dt = since_date
            since_date = since_date - timedelta(days=1)
            since_str = since_date.strftime("%d-%b-%Y").lstrip('0')

        if before_date:
            self.end_dt = before_date
            before_date = before_date + timedelta(days=1)
            before_str = before_date.strftime("%d-%b-%Y").lstrip('0')

        if days or (since_date and before_date):
            return f'SINCE {since_str}' + (f' BEFORE {before_str}' if before_date else '')
        elif since_date:
            return f'SINCE {since_str}'
        elif before_date:
            return f'BEFORE {before_str}'

        return ""

    def search_emails_by_date(self, days: int = None, since_date: datetime = None,
                              before_date: datetime = None, unread_only: bool = False,
                              senders: Union[str, List[str]] = None) -> List[str]:
        """–ü–æ–∏—Å–∫ –ø–∏—Å–µ–º –ø–æ –¥–∞—Ç–µ"""
        if not self.connected:
            return []

        try:
            date_criteria = self._build_date_criteria(days, since_date, before_date)

            criteria_parts = []
            if date_criteria:
                criteria_parts.append(date_criteria)
            if unread_only:
                criteria_parts.append('UNSEEN')

            criteria = f'({" ".join(criteria_parts)})' if len(criteria_parts) > 1 else (
                criteria_parts[0] if criteria_parts else "ALL"
            )

            return self.search_emails(criteria)

        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –ø–∏—Å–µ–º –ø–æ –¥–∞—Ç–µ: {e}")
            return []

    def get_email_details(self, email_uid: str) -> Dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–µ—Ç–∞–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø–∏—Å—å–º–µ"""
        if not self.connected or not email_uid:
            return {}

        try:
            status, msg_data = self.mail.uid('FETCH', email_uid, "(BODY.PEEK[HEADER])")
            if status != "OK":
                return {}

            email_headers = msg_data[0][1]
            msg = email.message_from_bytes(email_headers)

            subject = self._decode_header(msg["Subject"])
            from_ = self._decode_header(msg["From"])
            date = msg["Date"]
            date_dt = parsedate_to_datetime(date)

            if self.start_dt and self.end_dt:
                if not (self.start_dt <= date_dt <= self.end_dt):
                    return {}

            name, e_mail = parseaddr(from_)

            if e_mail not in self.senders:
                return {}

            status, msg_data = self.mail.uid('FETCH', email_uid, "(BODY.PEEK[])")
            if status != "OK":
                return {}

            email_body = msg_data[0][1]
            msg = email.message_from_bytes(email_body)

            email_info = {
                'uid': email_uid,
                'subject': subject,
                'from': from_,
                'date': date,
                'attachments': [],
                'excel_attachments': [],
                'body': '',
                'body_html': ''
            }

            email_info.update(self._process_email_content(msg))
            return email_info

        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–∏—Å—å–º–∞ {email_uid}: {e}")
            traceback.print_exc()
            return {}

    def _process_email_content(self, msg) -> Dict:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –ø–∏—Å—å–º–∞ –∏ –≤–ª–æ–∂–µ–Ω–∏–π"""
        body = ""
        body_html = ""
        attachments = []
        excel_attachments = []

        if msg.is_multipart():
            for part in msg.walk():
                content_type = part.get_content_type()
                content_disposition = str(part.get("Content-Disposition"))

                if content_type == "text/plain" and "attachment" not in content_disposition:
                    body = self._decode_payload(part) or body
                elif content_type == "text/html" and "attachment" not in content_disposition:
                    body_html = self._decode_payload(part) or body_html
                elif "attachment" in content_disposition or part.get_filename():
                    filename = part.get_filename()
                    if filename:
                        filename = self._decode_header(filename)
                        payload = part.get_payload(decode=True)
                        if payload:
                            attachment_info = {
                                'filename': filename,
                                'content_type': content_type,
                                'payload': payload,
                                'size': len(payload)
                            }
                            attachments.append(attachment_info)

                            if self._is_excel_file(filename):
                                excel_attachments.append(attachment_info)
        else:
            content_type = msg.get_content_type()
            if content_type == "text/plain":
                body = self._decode_payload(msg)
            elif content_type == "text/html":
                body_html = self._decode_payload(msg)

        return {
            'body': body,
            'body_html': body_html,
            'attachments': attachments,
            'excel_attachments': excel_attachments
        }

    def _is_excel_file(self, filename: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ñ–∞–π–ª Excel –¥–æ–∫—É–º–µ–Ω—Ç–æ–º"""
        excel_extensions = ['.xls', '.xlsx', '.xlsm', '.xlsb']
        file_ext = os.path.splitext(filename.lower())[1]
        return file_ext in excel_extensions

    def _decode_payload(self, part) -> str:
        """–î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ payload —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º –∫–æ–¥–∏—Ä–æ–≤–∫–∏"""
        try:
            payload = part.get_payload(decode=True)
            if not payload:
                return ""

            encoding = part.get_content_charset()
            if not encoding:
                detected = chardet.detect(payload)
                encoding = detected.get('encoding', 'utf-8')

            encodings_to_try = [encoding, 'utf-8', 'cp1251', 'koi8-r', 'iso-8859-1', 'windows-1251']

            for enc in encodings_to_try:
                try:
                    if enc:
                        return payload.decode(enc, errors='replace')
                except (UnicodeDecodeError, LookupError):
                    continue

            return payload.decode('utf-8', errors='replace')

        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è payload: {e}")
            return ""

    def _decode_header(self, header) -> str:
        """–î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ email"""
        if header is None:
            return ""

        try:
            decoded_parts = decode_header(header)
            decoded_header = ""
            for part, encoding in decoded_parts:
                if isinstance(part, bytes):
                    if encoding:
                        decoded_header += part.decode(encoding, errors='replace')
                    else:
                        for enc in ['utf-8', 'cp1251', 'iso-8859-1']:
                            try:
                                decoded_header += part.decode(enc, errors='replace')
                                break
                            except UnicodeDecodeError:
                                continue
                else:
                    decoded_header += part

            return decoded_header
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –∑–∞–≥–æ–ª–æ–≤–∫–∞: {e}")
            return str(header) if header else ""

    def _check_filter_conditions(self, text: str, contains: str = None,
                                 excludes: str = None) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π —Ñ–∏–ª—å—Ç—Ä–∞"""
        if contains:
            patterns = [r.strip().lower() for r in contains.split(";")]
            if not any(p in text.lower() for p in patterns):
                return False

        if excludes:
            patterns = [r.strip().lower() for r in excludes.split(";")]
            if any(p in text.lower() for p in patterns):
                return False

        return True

    def _check_attachment_approval(self, filename: str, email_rule: Filters) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–¥–æ–±—Ä–µ–Ω–∏—è –≤–ª–æ–∂–µ–Ω–∏—è –ø–æ –ø—Ä–∞–≤–∏–ª–∞–º"""
        if not email_rule:
            return True

        if not self._check_filter_conditions(filename, email_rule.filename_contains,
                                             email_rule.filename_excludes):
            return False

        if email_rule.extensions:
            extensions = [ext.strip() for ext in email_rule.extensions.split(",")]
            if not any(filename.lower().endswith(ext.lower()) for ext in extensions):
                return False

        return True

    def download_excel_attachments(self, email_info: Dict, download_folder: str = "unsort",
                                   email_rule: Filters = None) -> List[str]:
        """–°–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ç–æ–ª—å–∫–æ Excel –≤–ª–æ–∂–µ–Ω–∏–π –∏–∑ –ø–∏—Å—å–º–∞"""
        download_folder = os.path.join("attachments", str(download_folder))
        downloaded_files = []
        excel_attachments = email_info.get('excel_attachments', [])

        if not excel_attachments:
            return downloaded_files

        for attachment in excel_attachments:
            try:
                filename = attachment['filename']
                payload = attachment['payload']

                if not filename or not payload:
                    continue

                clean_filename = re.sub(r'[<>:"/\\|?*]', '_', filename)

                if not self._check_attachment_approval(clean_filename, email_rule):
                    continue

                filepath = os.path.join(download_folder, clean_filename)
                abs_filepath = os.path.join(pm.get_user_data(), filepath)

                os.makedirs(os.path.dirname(abs_filepath), exist_ok=True)

                counter = 1
                original_filepath = abs_filepath
                while os.path.exists(abs_filepath):
                    name, ext = os.path.splitext(original_filepath)
                    abs_filepath = f"{name}_{counter}{ext}"
                    filepath = os.path.join(download_folder, f"{Path(original_filepath).stem}_{counter}{ext}")
                    counter += 1

                with open(abs_filepath, 'wb') as f:
                    f.write(payload)

                downloaded_files.append(filepath)
                print(f"–°–∫–∞—á–∞–Ω Excel —Ñ–∞–π–ª: {clean_filename} ({len(payload)} bytes)")

            except Exception as e:
                print(f"–û—à–∏–±–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è Excel —Ñ–∞–π–ª–∞ {filename}: {e}")
                traceback.print_exc()

        return downloaded_files

    def get_emails_with_excel_attachments(self, email_uids: List[str]) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–∏—Å–µ–º —Å Excel –≤–ª–æ–∂–µ–Ω–∏—è–º–∏ –∏–∑ —Å–ø–∏—Å–∫–∞ UID"""
        emails_with_excel = []

        for email_uid in email_uids:
            print(f"–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–∏—Å—å–º–∞ {email_uids.index(email_uid) + 1}/{len(email_uids)}: {email_uid}")
            try:
                email_info = self.get_email_details(email_uid)
                if email_info and email_info.get('excel_attachments'):
                    print(f"–ù–∞–π–¥–µ–Ω–æ –ø–∏—Å—å–º–æ —Å Excel –≤–ª–æ–∂–µ–Ω–∏–µ–º: [{email_info.get('date')}] "
                          f"{email_info.get('from')}: {email_info.get('subject')}")
                    emails_with_excel.append(email_info)
            except Exception as e:
                print(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–∏—Å—å–º–∞ {email_uid}: {e}")
                continue

        return emails_with_excel

    def _filter_emails_by_limit(self, emails: List[Dict], vendor_id: int) -> List[Dict]:
        """–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–∏—Å–µ–º —Å —É—á–µ—Ç–æ–º –ª–∏–º–∏—Ç–∞ - –ø–æ 1 –¥–ª—è –∫–∞–∂–¥–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏"""
        configs = list_configs_for_vendor_id(vendor_id)

        cfgs = {cfg.id: {"cfg": cfg, "items": []} for cfg in configs}

        for email in emails:
            for cfg_id, value in cfgs.items():
                filename = email.get('filename', '')
                if value["cfg"].filename_template.strip().lower() in filename.lower():
                    value["items"].append(email)

        result = []
        for value in cfgs.values():
            if value["items"]:
                latest = max(value["items"], key=lambda x: datetime.fromisoformat(x['date']))
                result.append(latest)

        return result

    def download_all_excel_files(self,
                                 limit: int = None,
                                 days: int = None,
                                 since_date: datetime = None,
                                 before_date: datetime = None,
                                 folder: str = "attachments",
                                 unread_only: bool = False,
                                 senders: Union[str, List[str]] = None) -> Dict:
        """–°–∫–∞—á–∏–≤–∞–µ—Ç –≤—Å–µ Excel —Ñ–∞–π–ª—ã –∏–∑ –ø–∏—Å–µ–º"""

        if limit:
            email_uids = self.search_emails("ALL")
            search_description = f"–ø–æ—Å–ª–µ–¥–Ω–∏–µ {limit} –ø–∏—Å–µ–º"
        else:
            email_uids = self.search_emails_by_date(
                days=days,
                since_date=since_date,
                before_date=before_date,
                unread_only=unread_only,
                senders=senders
            )
            search_description = self._build_search_description(days, since_date, before_date,
                                                                unread_only, senders)

        if email_uids:
            print(f"–ö –æ–±—Ä–∞–±–æ—Ç–∫–µ –Ω–∞–π–¥–µ–Ω–æ {len(email_uids)} –ø–∏—Å–µ–º...")

        emails_with_excel = self.get_emails_with_excel_attachments(email_uids)

        return self._process_and_download_emails(emails_with_excel, folder, limit is not None)

    def _build_search_description(self, days, since_date, before_date, unread_only, senders):
        """–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –æ–ø–∏—Å–∞–Ω–∏—è –ø–æ–∏—Å–∫–∞"""
        if days:
            desc = f"–ø–∏—Å—å–º–∞ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ {days} –¥–Ω–µ–π"
        elif since_date and before_date:
            desc = f"–ø–∏—Å—å–º–∞ —Å {since_date} –ø–æ {before_date}"
        elif since_date:
            desc = f"–ø–∏—Å—å–º–∞ —Å {since_date}"
        elif before_date:
            desc = f"–ø–∏—Å—å–º–∞ –¥–æ {before_date}"
        else:
            desc = "–≤—Å–µ –ø–∏—Å—å–º–∞"

        if unread_only:
            desc += " (—Ç–æ–ª—å–∫–æ –Ω–µ–ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ)"
        if senders:
            sender_list = senders if isinstance(senders, list) else [senders]
            desc += f" (–æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª–∏: {', '.join(sender_list)})"

        return desc

    def _process_and_download_emails(self, emails_with_excel: List[Dict],
                                     folder: str, apply_limit: bool) -> Dict:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ –ø–∏—Å–µ–º"""
        download_results = {}

        for i, email_info in enumerate(emails_with_excel, 1):
            raw_from = email_info['from'].strip()
            print(f"–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–∏—Å—å–º–∞ {i}/{len(emails_with_excel)} {email_info['subject']}")

            match = re.search(r'[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}', raw_from)
            sender_email = match.group(0) if match else email_info['from']

            vendor_id, email_rule = self._find_vendor_and_rule(sender_email)

            if not vendor_id:
                continue

            if email_rule and not self._check_email_subject(email_info['subject'], email_rule):
                continue

            downloaded_files = self.download_excel_attachments(email_info, vendor_id, email_rule)

            if downloaded_files:
                self._save_letter_and_attachments(email_info, sender_email, vendor_id, downloaded_files)

                download_results[email_info['uid']] = {
                    'subject': email_info['subject'],
                    'from': email_info['from'],
                    'date': email_info['date'],
                    'downloaded_files': downloaded_files,
                    'excel_count': len(email_info['excel_attachments']),
                }

        return download_results

    def _find_vendor_and_rule(self, sender_email: str) -> tuple[Optional[int], Optional[Filters]]:
        """–ü–æ–∏—Å–∫ –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞ –∏ –ø—Ä–∞–≤–∏–ª–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è"""
        vendor_id = None
        email_rule = None

        if self.scope:
            for vendor, emails in self.scope.items():
                if sender_email in emails:
                    vendor_id = self._get_or_create_vendor(vendor)
                    break

        if self.db_scope:
            for rule in self.db_scope:
                if sender_email in [s.strip() for s in rule.senders.split(';')]:
                    v_name = get_vendor_name_by_id(rule.vendor_id)
                    vendor_id = self._get_or_create_vendor(v_name)
                    email_rule = rule
                    break

        return vendor_id, email_rule

    def _get_or_create_vendor(self, vendor_name: str) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å ID –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞ –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–≥–æ"""
        existing_vendor = next((v for v in self.vendors if v.name == vendor_name), None)
        if existing_vendor:
            return existing_vendor.id
        return add_vendor(vendor_name).id

    def _check_email_subject(self, subject: str, email_rule: Filters) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–µ–º—ã –ø–∏—Å—å–º–∞ –ø–æ –ø—Ä–∞–≤–∏–ª–∞–º"""
        return self._check_filter_conditions(subject, email_rule.subject_contains,
                                             email_rule.subject_excludes)

    def _save_letter_and_attachments(self, email_info: Dict, sender_email: str,
                                     vendor_id: int, downloaded_files: List[str]):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–∏—Å—å–º–∞ –∏ –≤–ª–æ–∂–µ–Ω–∏–π –≤ –ë–î"""
        d = datetime.strptime(email_info['date'], "%a, %d %b %Y %H:%M:%S %z")

        letter = Letter(
            letter_id=int(email_info['uid']),
            sender=sender_email,
            subject=email_info['subject'],
            date=d,
            vendor_id=vendor_id
        )

        try:
            add_letter(letter)
        except Exception:
            update_letter(letter)

        delete_attachments_by_letter(letter.letter_id)

        for file_path in downloaded_files:
            abs_path = Path(pm.get_user_data()) / file_path
            size = os.path.getsize(abs_path)

            attachment = Attachment(
                letter_id=int(email_info['uid']),
                file_name=os.path.basename(file_path),
                file_path=file_path,
                size=size
            )
            add_attachment(attachment)

    def get_all_prices(self, limit_by_folder=None, days=None, since_date=None,
                       before_date=None, folder="attachments", unread_only=False,
                       simple_scope: Filters = None):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –ø—Ä–∞–π—Å–æ–≤"""
        if not self.connect():
            return []

        try:
            self._setup_scope(simple_scope)
            results = {}
            out = []

            print(f"–ò—â–µ–º –ø–∏—Å—å–º–∞ –¥–ª—è –∞–¥—Ä–µ—Å–æ–≤: {', '.join(self.senders)}")

            folders_data = self.list_folders()
            for folder_line in folders_data:
                parts = folder_line.split('"|"')
                if len(parts) > 1:
                    folder_name = parts[-1].strip()
                    if folder_name in self.exluded_folders:
                        continue

                    decoded_name = decode_folder_name(folder_name)
                    print(f"–ò—â–µ–º –≤ –ø–∞–ø–∫–µ: {decoded_name}")

                    self.select_folder(folder_name)
                    results.update(self.download_all_excel_files(
                        limit=limit_by_folder,
                        days=days,
                        since_date=since_date,
                        before_date=before_date,
                        folder=folder,
                        unread_only=unread_only,
                        senders=self.senders
                    ))

            out = self._format_results(results)
            return out

        except Exception as e:
            traceback.print_exc()
            print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ø–∏—Å–µ–º: {e}")
            return []
        finally:
            self.disconnect()

    def _setup_scope(self, simple_scope: Filters = None):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±–ª–∞—Å—Ç–∏ –ø–æ–∏—Å–∫–∞"""
        if simple_scope:
            self.db_scope = [simple_scope]
        else:
            self.db_scope = []
            for vendor in self.vendors:
                if vendor.active:
                    self.db_scope.append(get_email_filter_by_vendor(vendor.id))

        self.senders = []
        for rule in self.db_scope:
            self.senders.extend(s.strip() for s in rule.senders.split(';'))

    def _format_results(self, results: Dict) -> List[Dict]:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤"""
        out = []

        if results:
            print("\n--- –î–µ—Ç–∞–ª–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è ---")
            for email_uid, info in results.items():
                if info['downloaded_files']:
                    print(f"\n‚úì –ü–∏—Å—å–º–æ: {info['subject']}")
                    print(f"  –û—Ç: {info['from']}")
                    print(f"  –î–∞—Ç–∞: {info['date']}")

                    for file_path in info['downloaded_files']:
                        out.append({
                            "subject": info['subject'],
                            "filename": file_path,
                            "date": info['date'],
                        })
                        file_size = os.path.getsize(os.path.join(pm.get_user_data(), file_path))
                        print(f"  üìä {os.path.basename(file_path)} ({file_size} bytes)")
        else:
            print("Excel —Ñ–∞–π–ª—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")

        return out


s = settings.get_settings()
client = YandexIMAPClient(
    s.get('email_username'),
    s.get('email_password'),
    s.get('email_server', 'imap.yandex.ru'),
    int(s.get('email_port', 993))
)

if __name__ == '__main__':
    client.get_all_prices(days=30)
